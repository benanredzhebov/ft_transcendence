1. needs Update the WebSocket connection in your frontend :

const socket = io('wss://localhost:3000', {
transports: ['websocket'],
secure: true
});

2. Read Canvas

3.There are 2 .gitignore files. Make it 1

Benan Notes. Should to fix :

1. While registering the aliases, if the window is changed, the bracket disappears. `FIXED`

- assignned new variable to track if the alias is registered `aliasRegistered = false`. added it to 'alias_registered'
- adjusted the event listener for the visibility change
- also re-promt on socket reconnect if not registered

2. After stopping the server and rerunning it, pressing "Back" in the game window does not make the result disappear. `FIXED`

- frontend socket.on -> disconnect part

3. After the tournament ends, pressing the "Return to Lobby" button does not display the results. `FIXED`

- Save tournament results in the state_update
- reset tournamentResults[] at the start of each new tournament(in the tournament_lobby handler) to avoid mixing results from previous tournaments.
- When the tournament ends I press Return to Lobby, your showTournamentResults function is called.

4. Should develop Tournament bracket to see all matches result `FIXED`

5. After the 1st match if 1 player press I'm ready button the countdown starts. Should wait to all players to press the button I'm ready `FIXED`

**PLAYER READY LOGIC FIX:**

- **Problem**: Tournament countdown started when only 1 player clicked "I'm Ready"
- **Root Cause**: `allPlayersReady()` checked all active players globally, not just current match players
- **Solution**: Modified `allPlayersReady()` in Tournament.js to specifically check current match players
- **Logic**: For real matches (player1 & player2), both must be ready. For bye matches, only the single player needs to be ready
- **Result**: Final match now properly waits for BOTH players to click "I'm Ready" before countdown

6. After the tournament has finsished -> Return to Lobby button -> Back to Dashboard button -> appears Disconnected for a while `No need no fix It's ok.`

7. Next match button no need after the second match. `FIXED`

8. After the first match check `I am ready button`. `FIXED`

9. **COUNTDOWN DISCONNECT ISSUES + TOURNAMENT RESULTS CONSISTENCY** `FIXED`

**DISCONNECT DURING COUNTDOWN:**

- **Problem**: Disconnecting during countdown caused next match to start automatically without both players being ready
- **Solution**: Added countdown cancellation when tournament players disconnect, proper ready state reset
- **Implementation**: Both backend countdown clearing and frontend dialog removal

**TOURNAMENT RESULTS DISPLAY INCONSISTENCY:**

- **Problem**: Different result formats appearing (raw objects vs formatted strings)
- **Root Cause**: Mixed usage of `tournament.allMatches` (raw objects) vs `tournament.getAllMatchResults()` (formatted strings)
- **Solution**: Standardized ALL `tournament_over` events to use `tournament.getAllMatchResults()`
- **Result**: Consistent bracket display showing proper formatted match results in all scenarios

- **Problem**: When player disconnects during countdown, next match starts automatically without "I'm Ready" requirements
- **Root Cause**: Countdown continued running after disconnect, triggering automatic match start
- **Solution**: Added countdown cancellation logic when tournament player disconnects
- **Frontend**: Added `countdown_cancelled` event handler to clear countdown dialogs
- **Result**: Disconnects now properly cancel countdown and reset ready states

10. **TOURNAMENT RESULTS DISPLAY INCONSISTENCY** `FIXED`

**INCONSISTENT BRACKET FORMATS:**

- **Problem**: Different tournament completion paths showed different result formats (objects vs formatted strings)
- **Root Cause**: Some code paths used `tournament.allMatches` (raw objects), others used `tournament.getAllMatchResults()` (formatted strings)
- **Solution**: Standardized ALL `tournament_over` emissions to use `tournament.getAllMatchResults()`
- **Result**: Consistent, properly formatted tournament results display in all scenarios (normal completion, forfeit wins, etc.)

Don't get a new socket for each alias registration.
SOCKET CONNECTION PATTERN:

1. One Socket Per Browser Tab/Window: Each player opens the game in their browser and gets one WebSocket connection to the server.

2. Alias Registration: When a player registers an alias, they're just associating their existing socket ID with a tournament alias. The socket connection stays the same.

3. Server-Side Tracking: The server maps socketId → alias in the tournament system, like this:

`// In Tournament.js`
`this.players.set(socketId, {`
`alias: "PlayerName",`
`isReady: false,`
`userId: user.userId,`
`username: user.username`
`});`

Example Flow:

*Player 1 opens browser → gets socket ID abc123
*Player 1 registers alias "Champion" → server maps abc123 → "Champion"
*Player 2 opens browser → gets socket ID def456
*Player 2 registers alias "Warrior" → server maps def456 → "Warrior"

Key Points:

✅ Same socket throughout: Registration, matches, tournament completion
✅ No reconnection needed: Alias registration is just metadata
✅ Persistent connection: Socket stays alive for the entire tournament
✅ Multi-player support: Each player has their own socket + alias
The alias is just a friendly name for tournament display, but all communication still happens through the original socket connection established when the player first loaded the game page.

Socket Creation Location:
In `game.ts`, around lines 650-660:

`// Socket connection`
`socket = io('https://127.0.0.1:3000', {`
`transports: ['websocket'],`
`secure: true,`
`query: {`
`local: (!tournamentMode && !aiMode).toString(),`
`mode: aiMode ? 'ai' : (tournamentMode ? 'tournament' : 'local')`
`}`
`});`

The Tournament.js file doesn't create sockets - it only manages the mapping between existing socket IDs and tournament data:`

The Flow:

1. Browser loads game page → renderGame() function is called
2. Socket creation → io() creates WebSocket connection to server
3. Server receives connection → New socket ID is generated (like abc123)
4. Player registers alias → socket.emit('register_alias', { alias, token })
5. Server maps socket to alias → tournament.registerPlayer(socket.id, alias, user)

Key edge cases to test for the game logic and tournament system :

Tournament Edge Cases

1. Odd Number of Players: Ensure the bracket handles byes correctly and no player is left unassigned. `OK`
2. Single Player Tournament: Verify the system gracefully handles or prevents tournaments with only one participant. `OK`
3. Simultaneous "I'm Ready" Presses: Multiple players press "I'm Ready" at the same time—check for race conditions or missed events. `OK`
4. Player Disconnects Mid-Tournament: Test what happens if a player disconnects during a match or between rounds. Is the match forfeited, or does the system wait? `FIXED - FORFEIT SYSTEM + BYE HANDLING + FINAL MATCH FIXES`

**FORFEIT WITH BYE HANDLING FIX:**

- **Root Issue**: Forfeit handler missing bye auto-processing logic that exists in normal match_ended handler
- **Symptom**: After forfeit, tournament shows "Winner vs BYE" instead of "Winner vs ActualOpponent"
- **Solution**: Added bye-handling loop to forfeit case to auto-advance bye matches
- **Match Announcement**: Uses proper `getCurrentMatchPlayers()` and sends `await_player_ready` to both players
- **Tournament Flow**: Now seamlessly handles forfeit → bye processing → next real match

**FINAL MATCH FORFEIT FIX:**

- **Problem**: Final match disconnects caused "match cancelled" instead of forfeit
- **Debugging**: Added comprehensive logging to track forfeit flow in all tournament stages
- **Robustness**: Improved error handling and fallback cases for edge scenarios
- **Consistency**: Final matches now handle disconnects same as earlier rounds (forfeit victory)

**PROPER DISCONNECT BEHAVIOR:**

- **During a match**: Disconnected player automatically forfeits, opponent wins and advances
- **Between rounds**: Player is removed from tournament, bracket adjusts automatically
- **Tournament continuation**: If ≥2 players remain, tournament continues; if <2 players, tournament is cancelled
- **User feedback**: Clear notifications about forfeits and cancellations
- **Automatic progression**: Winner is recorded, bracket updates, next match starts automatically

**Implementation Details:**

- Server: Enhanced disconnect handler with forfeit logic in server.js
- Tournament: Added getNextMatch() method for automatic progression
- Frontend: Added handlers for match_forfeit, match_cancelled, tournament_cancelled events
- UI: Proper dialog messages and tournament bracket visibility management

**Bug Fix Applied:**

- Fixed `recordWinner` call to use `winnerSocketId` instead of `winnerData` object
- Added proper forfeit scores (5-0 for winner)
- Improved error handling with try-catch block
- Fixed timing issue where disconnected player was removed before recording winner
- Added proper tournament state management and next match progression
- **ADDITIONAL FIX**: Fixed array access pattern for `tournamentWinner[1]` and `player[1]` (aliases)
- **ADDITIONAL FIX**: Added game pause and reset to prevent background game from continuing during forfeit
- **ADDITIONAL FIX**: Proper null checking for `player2` in match announcements

5. Alias Re-registration: A player tries to register a new alias after already registering one. Ensure the mapping updates or is blocked as intended. `FIXED`

6. Multiple Tabs/Windows: Same user opens multiple tabs—does the system create duplicate sockets or aliases? `FIXED`

**DUPLICATE USER REGISTRATION FIX:**

- **Problem**: Same user could register multiple aliases from different browser tabs, allowing one person to participate as multiple "players" in a tournament
- **Security Issue**: Tournament integrity compromised - one user could control multiple tournament slots
- **Root Cause**: System only checked for duplicate aliases, not duplicate userIds
- **Solution**: Added userId validation in `registerPlayer()` method to prevent same user from registering multiple times
- **Implementation**:
  - Backend: Enhanced `Tournament.registerPlayer()` to check both alias and userId uniqueness
  - Server: Improved error messages to distinguish between "alias taken" vs "user already registered"
  - Frontend: Updated error handling to display specific error messages
- **Result**: Each authenticated user can only register once per tournament, maintaining fair play and tournament integrity

7. Tournament Reset During Active Match: Admin or system triggers a reset while a match is ongoing. Ensure all states are cleared and no orphaned matches remain. `FIXED`

**TOURNAMENT RESET DURING ACTIVE MATCH FIX:**

- **Problem**: Server restart during active tournament match caused inconsistent states, connection lost messages, and orphaned matches
- **Root Issues**:
  - No automatic socket reconnection configured
  - Poor disconnect/reconnect UX with simple page reload
  - No server restart detection or tournament state recovery
  - Missing administrative reset capability
- **Solution**: Comprehensive tournament reset and reconnection system
- **Backend Changes**:
  - Added server initialization cleanup to reset states on startup
  - Enhanced connection handler to detect tournament clients after server restart
  - Added `admin_reset_tournament` handler for manual resets
  - Proper tournament state cleanup and client notification
- **Frontend Changes**:
  - Added automatic socket reconnection with configurable attempts and delays
  - Enhanced disconnect handling with status updates and different messages
  - Tournament state preservation in sessionStorage for reconnection scenarios
  - Added `tournament_reset` event handler for server restart notifications
  - Improved reconnection logic with proper state restoration
- **User Experience**:
  - Clear "Tournament reset due to server restart" messages
  - Automatic reconnection attempts with progress display
  - Clean state reset with no orphaned matches
  - Proper redirect to dashboard with session validation
- **Testing**: Created admin testing utilities for manual reset triggers and connection simulation
- **Edge Cases Covered**: Dual socket architecture, session management, state synchronization, various disconnect scenarios
- **Result**: Server restarts during tournaments now properly notify all players, reset all states, and allow clean restart of new tournaments

8. Rapid Tournament Start/Stop: Start and immediately stop tournaments repeatedly to check for memory leaks or lingering state.
9. Bracket Visibility: Changing browser tab/window during registration or matches—ensure bracket and state persist or recover correctly.  `OK`
10. Return to Lobby/Back to Dashboard: After tournament ends, test navigation to lobby/dashboard and verify results/history are displayed and not mixed with previous tournaments. `FIXED - DASHBOARD REDIRECT + FINAL MATCH FORFEIT`

**DASHBOARD REDIRECT FIX:**

- **Authentication Check**: Added `sessionStorage.getItem('authToken')` validation before redirecting
- **Correct Route**: Changed `/dashboard.html` to `/dashboard` (SPA routing)
- **Error Handling**: Shows alert and redirects to `/login` if session expired
- **Applied to all dashboard buttons**: tournament_cancelled, tournament_error, game overlays

**FINAL MATCH FORFEIT FIX:**

- **Smart Tournament End**: If 1 player remains after disconnect in final match, they win the tournament
- **Proper Winner Declaration**: Remaining player is declared tournament winner instead of cancelling
- **Tournament vs Cancel Logic**: Only cancels if <2 players and tournament not in final state

Game Logic Edge Cases

1. Score Overflow: Unusually high scores or rapid scoring—ensure score display and logic do not break.
2. Simultaneous Paddle Movement: Both players move paddles at the same time—check for sync issues.
3. Ball Stuck/Infinite Loop: Ball gets stuck in a corner or bounces infinitely—ensure game can recover.
4. AI Mode vs Tournament Mode: Switching between modes—verify correct socket query and game logic.
5. Countdown/Ready State: Countdown starts before all players are ready, or countdown box overlaps with bracket—check UI and logic.
6. Game End Conditions: Game ends due to disconnect, timeout, or score—ensure proper winner assignment and result recording.
7. Multiple "Next Match" Events: Ensure "Next Match" button/events do not appear or trigger after the second match (already fixed, but re-test).

General Edge Cases

1. Socket Reconnection: Socket disconnects and reconnects—verify alias re-prompt and state recovery.
2. Server Restart: Server is stopped and restarted during a tournament—check for proper client/server state sync.
3. Invalid Data: Malformed or missing data sent from client—ensure server validation and error handling.
4. Concurrent Tournaments: Multiple tournaments started at once—ensure isolation of state and results.

...........
Vullnerable
...........

1. A denial-of-service (DoS) attack is a cyberattack that aims to make a computer system, website, or network unavailable to legitimate users by overwhelming it with traffic or resource requests. This disruption can occur due to a single source (DoS) or multiple sources (DDoS), all targeting the same resource.
   Here's a more detailed breakdown:
   Goal:
   DoS attacks aim to prevent legitimate users from accessing a service, such as a website, email, or online banking.
   Method:
   Attackers flood the target with traffic, often by sending more requests than the system can handle, or by exploiting vulnerabilities in the system.
   Impact:
   A successful DoS attack can result in downtime, loss of availability of services, and potentially financial losses for the targeted organization.
   Types:
   DoS attacks can be volumetric (aimed at bandwidth), protocol-based (aimed at specific protocols), or application layer (aimed at specific applications).
   DDoS vs. DoS:
   A Distributed Denial-of-Service (DDoS) attack is a type of DoS attack that utilizes multiple sources to overwhelm the target, making it harder to detect and mitigate.

2. A MIME type, also known as a media type or content type, is a standard that identifies the format of a file or resource. It's a two-part identifier, consisting of a type and a subtype, like text/plain or image/jpeg. These types are used by web servers, browsers, and other applications to determine how to handle the file.
   Here's a more detailed explanation:
   Purpose:
   MIME types tell applications (like web browsers) what kind of content they are dealing with. This is crucial for proper rendering, downloading, or processing of files.
   Structure:
   A MIME type has the format type/subtype, for example:
   text/html: Indicates an HTML document.
   image/jpeg: Indicates a JPEG image.
   application/json: Indicates a JSON file.
   audio/mpeg: Indicates an MP3 audio file.
   Importance:
   Web Servers: Web servers use MIME types in the Content-Type header of HTTP responses to inform browsers about the type of content being sent.
   Browsers: Browsers use MIME types to determine how to display or handle a file. If the MIME type is incorrect, the browser might not display the file correctly (e.g., displaying code instead of rendering an image).
   Operating Systems: Some operating systems also use MIME types for file handling and association.
   Where to find them:
   The Internet Assigned Numbers Authority (IANA) is the official authority for MIME types. You can find the official list on their Media Types page.
   Examples:
   text/plain: Plain text
   text/css: Cascading Style Sheets
   application/pdf: PDF documents
   image/png: PNG images
   video/mp4: MP4 videos
   audio/mpeg: MP3 audio
   How they work:
   When a browser requests a file, the server sends back the file along with a Content-Type header indicating its MIME type. The browser then uses this information to process the file. For instance, if the server sends Content-Type: image/jpeg, the browser knows to treat the response as a JPEG image and render it accordingly.
   In essence, MIME types are a fundamental part of how the internet and other systems handle different file formats, ensuring that resources are interpreted and displayed correctly.
